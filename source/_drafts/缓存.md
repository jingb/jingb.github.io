---
title: 缓存
tags:
---

# 概念
* 缓存穿透
不存在的key，放个null进缓存

* 缓存雪崩
用加锁或者队列的方式保证缓存的单线 程（进程）写
在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低

* 缓存击穿
热点数据，读db的时候要加锁，只一个请求去读，然后载入到缓存里


# 分类
应用级缓存
* 堆内、堆外 堆外不影响GC(EhCache、MapDB)

堆内
Guava 相比map，提供了容量、统计等API


# 并发更新缓存方式

**问题** A线程先删缓存，此时B读缓存没命中，读了数据库的老数据，存入缓存，B线程更新了数据库。**此时缓存里的是脏数据**

* Cache Aside Pattern
先更新DB，再删除缓存
**应用程序自己处理**

* Cache as SOR
 * Read/Write Through Pattern
     **Read/Write Through套路是把更新数据库（Repository）的操作由缓存自己代理了。可以理解为，应用认为后端就是一个单一的存储，而存储自己维护自己的Cache**
 * Write Behind Caching Pattern(Write Back)
   异步写，不细看

# 注意
* 事务操作数据库后，不要把更新redis的操作放到缓存中，因为这是有网络请求的
* redis 大value，**压缩**或者考虑拆成小value，客户端查多次，再自己做聚合
* 轮询的优点是请求均匀，但会降低命中率(一致性hash可以解决)，但可以避免热点数据导致一台机子负载太重。动态方案，压力大时从一致性hash降级为轮询，一般情况为一致性hash。推热点数据到nginx
* 

