---
title: linuxSysPerformance
tags:
---

![参考图片](https://static001.geekbang.org/resource/image/9e/7a/9ee6c1c5d88b0468af1a3280865a6b7a.png)
# cpu相关
## load
什么含义？单位时间内，正在使用cpu和等待cpu和等待io的进程数，可以简称为活跃 -> 啥是活跃，为毛 -> sps出来 进程是R(Running或Runnable)或者不可中断(D)的，**比方磁盘写数据，不可中断，容易出现数据不一致，本质上是一种保护**，因为load看到是系统的繁忙程度，而不是cpu使用率 -> **超过70%算负载过高，比方单cpu，超过0.7**

- cpu使用率和平均负载不要混淆，比方io密集型的应用，等待io的进程也会使负载升高，但cpu使用率并不高。cpu密集型的，此时负载和cpu利用率的表现是一致的
- 案例是用 stress 模拟压力，用mpstat pidstat 看系统情况

看评论 
htop比较现实，忽略里面用的分析工具 
分3情况 cpu密集 io密集 大量进程的情况 **都有可能造成负载高**
负载计算的代码网上有些文章 -> 逻辑**线程**数？ 

<!-- more -->

## cpu上下文切换
* 进程、线程、中断 上下文切换3种
  * 进程的切换比方进程1执行的时候某些资源条件不满足，肯定要把cpu让出来；分配的时间片用完了；自己sleep之类；高优先级的进程进来了；硬件的中断进来了，比方断电了
  * 线程的上下文切换，如果是只有一个线程，可以理解成和进程上下文切换一样；线程自己也有私有数据如栈和寄存器；多个线程共享进程的部分数据，切换的时候成本会比进程切换低一些
* vmstat cs可以查看**总体**切换次数 pidstat -w 可以看进程级别的切换情况 
* 多长时间内多少次切换算多 和cpu性能有关系，数量级的变化得关注
 * 自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题；
 * 非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈；
 * 中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型

## 不可中断进程和io
[案例链接](https://time.geekbang.org/column/article/71382?utm_source=pc&utm_medium=geektime&utm_content=pcchaping&utm_term=pc_interstitial_194)
**里面用了dstat去同时看cpu和io的情况，待排查vmstat能不能满足，可以的话忘记dstat**
**案例的c代码使用了Direct Io导致io瓶颈，搞懂啥时候时候使用Direct io**

## cpu利用率
* top看的是3秒 ps看的是进程整个生命周期
* /proc/stat /proc/$pid/stat 里cpu相关数据可以算出cpu利用率 每一列的含义可以看man proc
* {% asset_img cpu利用率计算.png %}
* perf top -p 21515 分析cpu高的进程 perf record可以持久化数据
* [cpu很高但top找不到进程的案例](https://time.geekbang.org/column/article/70822)
 * 进程不停的崩溃重启，短时进程 top监控不到 -> 因为pid一直变，无法跟踪，所以用 pstree 找这些进程的父进程 -> 找到有问题的父进程后，分析代码 -> 用perf记录一段时间的现象，验证

## 进程基础
### 状态
用ps和top有一列会展示 
运行（R）、空闲（I）、不可中断睡眠（D）Disk sleep、可中断睡眠（S）、僵尸（Z）以及暂停（T）
**不可中断状态，表示进程正在跟硬件交互，为了保护进程数据和硬件的一致性，系统不允许其他进程或中断打断这个进程。进程长时间处于不可中断状态，通常表示系统有 I/O 性能问题。**
**僵尸进程表示进程已经退出，但它的父进程还没有回收子进程占用的资源。短暂的僵尸状态我们通常不必理会，但进程长时间处于僵尸状态，就应该注意了，可能有应用程序没有正常处理子进程的退出。**

### 中断
Linux 中的中断处理程序分为上半部和下半部：
* 上半部对应硬件中断，用来快速处理中断。 也叫硬中断。
* 下半部对应软中断，用来异步处理上半部未完成的工作。
分软、硬是因为，如果中断处理程序耗时太长，可能会导致丢失中断信号

```
网卡接收到数据包后，会通过硬件中断的方式，通知内核有新的数据到了。这时，内核就应该调用中断处理程序来响应它。
对上半部来说，既然是快速处理，其实就是要把网卡的数据读到内存中，然后更新一下硬件寄存器的状态（表示数据已经读好了），最后再发送一个软中断信号，通知下半部做进一步的处理。
而下半部被软中断信号唤醒后，需要从内存中找到网络数据，再按照网络协议栈，对数据进行逐层解析和处理，直到把它送给应用程序
```

![](https://static001.geekbang.org/resource/image/59/ec/596397e1d6335d2990f70427ad4b14ec.png)
![](https://static001.geekbang.org/resource/image/7a/17/7a445960a4bc0a58a02e1bc75648aa17.png)







